# Green Energy Token Contract Technical Documentation

## Overview

The Green Energy Token (GET) contract is an ERC20-compliant token designed to tokenize assets from Carbon Credit. The contract includes functionality to track carbon footprints, allow token purchases, and compensate for carbon emissions. The contract also manages ownership and integrates with IoT devices for certified companies.

## Table of Contents
1. [License](#license)
2. [Prerequisites](#prerequisites)
3. [Import Statements](#import-statements)
4. [Contract Definition](#contract-definition)
5. [Structs](#structs)
    - [CarbonFootprintRecord](#carbonfootprintrecord)
6. [State Variables](#state-variables)
7. [Events](#events)
8. [Modifiers](#modifiers)
9. [Constructor](#constructor)
10. [Functions](#functions)
    - [mint](#mint)
    - [addFootprint](#addfootprint)
    - [withdraw](#withdraw)
    - [getFootPrint](#getfootprint)
    - [buy](#buy)
    - [getIOT](#getiot)
    - [compensate](#compensate)
    - [changeOwner](#changeowner)
    - [approveIOT](#approveiot)
    - [isCertified](#iscertified)
    - [getCertifiedAddresses](#getcertifiedaddresses)
    - [getOwner](#getowner)
    - [getFootprintRecords](#getfootprintrecords)

## License

```solidity
// SPDX-License-Identifier: MIT
```

## Prerequisites

- Solidity ^0.8.6
- `StandardERC20` contract for ERC20 functionality

## Import Statements

```solidity
import "./StandardERC20.sol";
```

## Contract Definition

```solidity
contract GreenEnergyToken is StandardERC20
```

## Structs

### CarbonFootprintRecord

```solidity
struct CarbonFootprintRecord {
    uint256 timestamp;
    address company;
    uint256 footprint;
    string action; // "add" for addition, "reduce" for reduction
}
```

## State Variables

- `mapping(address => uint) public footprintGenerated`: Tracks the carbon footprint generated by each company.
- `mapping(address => address) public approvedIot`: Maps companies to their approved IoT devices.
- `address public owner`: Owner of the contract.
- `address[] public certifiedAddresses`: List of certified addresses.
- `CarbonFootprintRecord[] public footprintRecords`: List of all carbon footprint records.

## Events

```solidity
event Buy(address indexed to, uint indexed footPrint, uint indexed amount);
event Compensate(address indexed to, uint indexed footPrint, uint indexed amount);
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```

## Modifiers

### onlyOwner

```solidity
modifier onlyOwner() {
    require(msg.sender == owner, "Caller is not the owner");
    _;
}
```

## Constructor

```solidity
constructor() StandardERC20("Green Energy Token", "GET", 100 * 10**18) {
    require(msg.sender != address(0), "Invalid owner address");
    owner = msg.sender;
}
```

## Functions

### mint

```solidity
function mint(uint256 amount) public onlyOwner {
    _mint(address(this), amount);
}
```

### addFootprint

```solidity
function addFootprint(address company, uint256 footprint) public onlyOwner {
    footprintGenerated[company] += footprint;
    footprintRecords.push(CarbonFootprintRecord(block.timestamp, company, footprint, "add"));
}
```

### withdraw

```solidity
function withdraw() public onlyOwner {
    uint balance = address(this).balance;
    payable(owner).transfer(balance);
}
```

### getFootPrint

```solidity
function getFootPrint(address company) public view returns (uint256) {
    return footprintGenerated[company];
}
```

### buy

```solidity
function buy() public payable {
    require(msg.value > 0, "Value must be greater than 0");
    uint256 amount = msg.value;
    _transfer(address(this), msg.sender, amount);
    emit Buy(msg.sender, footprintGenerated[msg.sender], amount);
}
```

### getIOT

```solidity
function getIOT(address company) public view returns (address) {
    return approvedIot[company];
}
```

### compensate

```solidity
function compensate(uint256 footprint) public {
    uint256 amount = (footprint * 10**18) / 1000;
    require(balanceOf(msg.sender) >= amount, "Insufficient balance to compensate");
    require(footprintGenerated[msg.sender] >= footprint, "Insufficient carbon footprint to compensate");

    _burn(msg.sender, amount);
    footprintGenerated[msg.sender] -= footprint;
    footprintRecords.push(CarbonFootprintRecord(block.timestamp, msg.sender, footprint, "reduce"));

    emit Compensate(msg.sender, footprint, amount);
}
```

### changeOwner

```solidity
function changeOwner(address newOwner) public onlyOwner returns (bool) {
    require(newOwner != address(0), "New owner is the zero address");
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
    return true;
}
```

### approveIOT

```solidity
function approveIOT(address company, address iotDevice) public onlyOwner {
    approvedIot[company] = iotDevice;
    if (iotDevice != address(0) && !isCertified(company)) {
        certifiedAddresses.push(company);
    }
}
```

### isCertified

```solidity
function isCertified(address company) public view returns (bool) {
    for (uint i = 0; i < certifiedAddresses.length; i++) {
        if (certifiedAddresses[i] == company) {
            return true;
        }
    }
    return false;
}
```

### getCertifiedAddresses

```solidity
function getCertifiedAddresses() public view returns (address[] memory) {
    return certifiedAddresses;
}
```

### getOwner

```solidity
function getOwner() public view returns (address) {
    return owner;
}
```

### getFootprintRecords

```solidity
function getFootprintRecords() public view returns (CarbonFootprintRecord[] memory) {
    return footprintRecords;
}
```

## StandardERC20 Contract

### Import Statements

```solidity
interface IERC20
```

### Contract Definition

```solidity
contract StandardERC20 is IERC20
```

## State Variables

- `mapping (address => uint256) private _balances`: Tracks the balance of each address.
- `mapping (address => mapping (address => uint256)) private _allowances`: Tracks the allowances for each address.
- `uint256 private _totalSupply`: Tracks the total supply of the token.
- `string private _name`: Name of the token.
- `string private _symbol`: Symbol of the token.
- `uint8 private _decimals`: Number of decimal places for the token (default is 18).

## Constructor

```solidity
constructor (string memory name_, string memory symbol_, uint256 totalSupply_) {
    _name = name_;
    _symbol = symbol_;
    _decimals = 18;
    _totalSupply = totalSupply_;
    _balances[address(this)] += totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
}
```

## Functions

### name

```solidity
function name() public view returns (string memory) {
    return _name;
}
```

### symbol

```solidity
function symbol() public view returns (string memory) {
    return _symbol;
}
```

### decimals

```solidity
function decimals() public view returns(uint8) {
    return _decimals;
}
```

### totalSupply

```solidity
function totalSupply() public view override returns (uint256) {
    return _totalSupply;
}
```

### balanceOf

```solidity
function balanceOf(address account) public view override returns (uint256) {
    return _balances[account];
}
```

### transfer

```solidity
function transfer(address recipient, uint256 amount) public override returns (bool) {
    _transfer(msg.sender, recipient, amount);
    return true;
}
```

### approve

```solidity
function approve(address spender, uint256 amount) public override returns (bool) {
    _approve(msg.sender, spender, amount);
    return true;
}
```

### allowance

```solidity
function allowance(address owner, address spender) public override view returns(uint256) {
    return _allowances[owner][spender];
}
```

### transferFrom

```solidity
function transferFrom(address sender, address recipient, uint256 amount) public override returns(bool) {
    _transfer(sender, recipient, amount);
    _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    return true;
}
```

### _transfer

```solidity
function _transfer(address sender, address recipient, uint256 amount) internal {
    require(recipient != address(0),"ERC20: transfer from zero transfer");
    require(sender != address(0),"ERC20: transfer from zero transfer");
    
    _balances[sender] -= amount;
    _balances[recipient] += amount;
    emit Transfer(sender, recipient, amount);
}
```

### _approve

```solidity
function _approve(address owner, address spender, uint256 amount) internal {
    require(spender != address(0),"ERC20: transfer from zero transfer");
    require(owner != address(0),"ERC20: transfer from zero transfer");
    _allowances[owner][spender]

 = amount;
    emit Approval(owner, spender, amount);
}
```

### _mint

```solidity
function _mint(address account, uint256 amount) internal virtual {
    require(account != address(0), "ERC20: mint to the zero address");

    _totalSupply += amount;
    _balances[account] += amount;
    emit Transfer(address(0), account, amount);
}
```

### _burn

```solidity
function _burn(address account, uint256 amount) internal virtual {
    require(account != address(0), "ERC20: burn from the zero address");

    uint256 accountBalance = _balances[account];
    require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
    _balances[account] = accountBalance - amount;
    _totalSupply -= amount;

    emit Transfer(account, address(0), amount);
}
```